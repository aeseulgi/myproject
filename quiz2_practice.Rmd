---
title: "quiz2_practice"
author: "HyeongHwan Kim"
date: "2023-11-26"
output: html_document
---

https://rpubs.com/neip313/672316


# Creating tibbles

```{r}
library("tidyverse")
```

```{r}
head(iris)
```
```{r}
as_tibble(iris)
```

```{r}
tibble(
  x = 1:5,
  y = 1,
  z = x^2 + y
)
```

```{r}
tribble(
  ~x, ~y, ~z,
  "a", 2, 3.6,
  "b", 1, 8.5
) #얘도 똑같이 tibble 자료형을 만드는 애다.
```

# Subsetting  

```{r}
df <- tibble(
  x = runif(5),
  y = rnorm(5)
)
```

```{r}
df$x # vector
```
```{r}
df[['x']] # vector
``` 

```{r}
df['x'] # tibble
```
```{r}
df[[1]]
```
```{r}
df %>%
  .$x
# 이 코드에서의 '.'은 파이프 연산자 %>%, 왼쪽에 있는 데이터프레임(df)을 오른쪽에 있는 함수(.$x)의 첫 번째 인수로 전달하는 역할을 합니다.
```

```{r}
df %>%
  .[["x"]]
```
# Data Import  

```{r}
library(readr)
```

```{r}
# heights <- read_csv("data/heights.csv")
```
```{r}
read_csv("a,b,c
         1,2,3
         4,5,6")
```
```{r}
read_csv2("a;b;c
         1;2;3
         4;5;6")
```

```{r}
read_csv("The first line of metadata
      The second line of metadata
      x,y,z
      1,2,3", skip = 2)
```
```{r}
read_csv("# A comment I want to skip
      x,y,z
      1,2,3", comment = "#")
```
```{r}
read_csv("1,2,3\n4,5,6", col_names = FALSE)
```
```{r}
read_csv("1,2,3\n4,5,6", col_names = FALSE)
```
```{r}
read_csv("1,2,3\n4,5,6", col_names = c("x", "y", "z"))
```


```{r}
read_csv("a,b,c\n1,2,.", na = ".")
```
# Parsing a vector  

parse_*(): string을 특정 type으로 바꿈.  

```{r}
parse_logical(c("TRUE", "FALSE", "NA"))
```
```{r}
parse_integer(c("1", "2", "3"))
```
```{r}
parse_date(c("2010-01-01", "1979-10-14"))
```
```{r}
parse_integer(c("1", "231", ".", "456"), na = ".")
```
```{r}
x <- parse_integer(c("123", "345", "abc", "123.45"))
```
대충 경고 메시지... 

```{r}
x
```

# Numbers  

```{r}
  parse_double("1.23")
```

```{r}
  parse_double("1,23", locale = locale(decimal_mark = ","))
```

오... 숫자만 따로 떼어내는 앤 가보다.

```{r}
  parse_number("$100")
```

```{r}
  parse_number("20%")
```
```{r}
  parse_number("It cost $123.45")
```
```{r}
  parse_number("$123,456,789")
```
```{r}
  parse_number("123.456.789", locale = locale(grouping_mark = "."))
```
```{r}
  parse_number("123'456'789", locale = locale(grouping_mark = "'"))
```
# Strings  

```{r}
charToRaw("Hadley")
```
```{r}
x1 <- "El Ni\xf1o was particularly bad this year"   # Latin1 (aka ISO-8859-1)
x2 <- "\xbe\xc8\xb3\xe7\xc7\xcf\xbc\xbc\xbf\xe4"    # EUC-KR (Korean)
  
parse_character(x1, locale = locale(encoding = "Latin1"))
```
```{r}
parse_character(x2, locale = locale(encoding = "EUC-KR"))
```
```{r}
fruit <- c("apple", "banana")
parse_factor(c("apple", "banana", "bananana"), levels = fruit)
```

팩터형은 가질 수 있는 값을 미리 알고 있는 범주형 변수를 말한다. 예상하지 못한 값이 있을 때 경고를 생성하려면 parse_factor함수에 레벨 벡터를 제공해주면 된다.  

```{r}
fruit <- c("apple", "banana")
parse_factor(c("apple", "banana", "banana"), levels = fruit)
```
```{r}
parse_datetime("2010-10-01T2010")
#T어쩌구는 시간인 듯.
```
```{r}
parse_datetime("20101010")
```
datetime은 시간까지 파싱.

```{r}
parse_date("2010-10-01")
```
date는 날짜만 파싱.

```{r}
library(hms)
parse_time("01:10 am")
```

```{r}
parse_time("20:10:01")
```
time은 시간만 파싱.  

Parsing files

R은 휴리스틱하게 열의 type을 결정.  
그런데 1000개의 행만을 살펴보고 결정하는 것이라 오류가 발생할 수 있음.  
그러한 경우들에 대해 1. 직접 type을 설정하거나 2. 1000개보다 많은 행을 살펴보도록 지시할 수 있음.

```{r}
challenge <- read_csv(readr_example("challenge.csv"))
```

```{r}
problems(challenge)
```

```{r}
challenge <- read_csv(
    readr_example("challenge.csv"), 
    col_types = cols(
      x = col_double(),
      y = col_character()
    )
  )
```

```{r}
tail(challenge)
```
```{r}
challenge <- read_csv(
    readr_example("challenge.csv"), 
    col_types = cols(
      x = col_double(),
      y = col_date()
    )
  )
tail(challenge)
```

```{r}
challenge2 <- read_csv(readr_example("challenge.csv"), guess_max = 1001)
```
```{r}
challenge2 <- read_csv(readr_example("challenge.csv"),
                       col_types = cols(.default = col_character()))
tail(challenge2)
```
```{r}
df <- tribble(
      ~x,  ~y,
      "1", "1.21",
      "2", "2.32",
      "3", "4.56"
    )
df
```
```{r}
type_convert(df)
# 휴리스틱한 파싱 방법을 문자형 열에 적용
```

# Writing to a file

```{r}
write_csv(challenge, "challenge.csv")
```

# Tidy data  

```{r}
table1
```

```{r}
table2
```

```{r}
table3
```
```{r}
table4a
```

```{r}
table4b
```

```{r}
# Compute rate per 10,000
table1 %>% 
  mutate(rate = cases / population * 10000)

# Compute cases per year
table1 %>% 
  count(year, wt = cases)

# Visualise changes over time
ggplot(table1, aes(year, cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country))
```

# Spreading and gathering  

gather: wide format -> long format

gather(
  data = 데이터,
  "원래 데이터에서 긴 형태로 나열하게 될 변수명들",
  key = "긴 형태로 나열하게 될 변수명",
  value = "key 변수에 대한 값 변수명",
  -var1, -var2, ... # 고려하지 않는 변수
)


```{r}
table4a
```


```{r}
table4a %>%
  gather('1999', '2000', key = "year", value = "cases")
```
```{r}
tidy4a <- table4a %>% 
      gather(`1999`, `2000`, key = "year", value = "cases")
tidy4b <- table4b %>% 
      gather(`1999`, `2000`, key = "year", value = "population")
left_join(tidy4a, tidy4b)  # we'll learn about this in Ch. 13
```
# Spreading  

spread(
  data = 데이터,
  key = "원래 데이터에서 펼쳐질 변수명",
  value = "key 변수에 대한 값 변수명"
)

```{r}
table2
```


```{r}
spread(table2, key = type, value = count)
```
# Separating and uniting

```{r}
table3
```
separate() 함수는 여러 개의 변수 값 또는 특정 값이나 구분자로 되어 있는 데이터를 분리하는 역할을 합니다.  

```{r}
table3 %>%
  separate(rate, into = c("cases", "population"))
```
```{r}
table3 %>%
  separate(rate, into = c("cases", "population"), convert = TRUE) # type_convert 적용 
```
```{r}
table3 %>% 
      separate(year, into = c("century", "year"), sep = 2)
# 두 번째 문자 전후로 나눔.  
```
If numeric, sep is interpreted as character positions to split at. Positive values start at 1 at the far-left of the string; negative value start at -1 at the far-right of the string. The length of sep should be one less than into.

# Unite  

```{r}
table5
```

unite(
  data = 데이터,
  col = 합친 결과를 저장할 새로운 열의 이름,
  합칠 열의 이름 나열,
  sep = 열을 합칠 때 사용할 구분자를 지정,
  remove = 합친 열들을 원본 데이터프레임에서 제거할지 여부 지정 (default = TRUE)
)

```{r}
table5 %>%
  unite(new, century, year, sep = "")
```



# Combine tables  

```{r}
library(nycflights13)
```
```{r}
flights
```
```{r}
airlines
```
```{r}
airports
```

```{r}
planes
```
```{r}
weather
```

# Keys
A key is a variable (or set of variables) that uniquely identifies an observation.

A primary key uniquely identifies an observation in its own table, e.g., planes$tailnum

A foreign key uniquely identifies an observation in another table, e.g., flights$tailnum

# Mutating joins  

```{r}
x <- tribble(
  ~key, ~val_x,
  1, "x1",
  2, "x2",
  3, "x3"
)

y <- tribble(
  ~key, ~val_y,
  1, "y1",
  2, "y2",
  4, "y3"
)
```

inner_join: key에서 교집합만 반환  

```{r}
inner_join(x, y, by = "key")
```
```{r}
x %>%
  inner_join(y, by = "key")
```
outer_join: 종류가 세 개 있다.  
(x, y) 순서일 때,  
left_join: x의 모든 관측값을 내버려둠.  
right_join: y의 모든 관측값을 내버려둠.  
full_join: x, y의 모든 관측값을 내버려둠.

```{r}
left_join(x, y, by = "key")
```

```{r}
right_join(x, y, by = "key")
```

```{r}
full_join(x, y, by = "key")
```

# Duplicate keys  

```{r}
x <- tribble(
  ~key, ~val_x,
  1, "x1",
  2, "x2",
  2, "x3",
  1, "x4"
)
y <- tribble(
  ~key, ~val_y,
  1, "y1",
  2, "y2"
)
left_join(x, y, by = "key")
```
```{r}
    x <- tribble(
      ~key, ~val_x,
         1, "x1",
         2, "x2",
         2, "x3",
         3, "x4"
    )
    y <- tribble(
      ~key, ~val_y,
         1, "y1",
         2, "y2",
         2, "y3",
         3, "y4"
    )
    left_join(x, y, by = "key")
```
key가 중복되는 경우, 가능한 모든 조합을 반환한다.  

```{r}
flights2 <- flights %>% 
      select(year:day, hour, origin, dest, tailnum, carrier)
flights2
```

```{r}
weather
```


# Defining the key columns  

```{r}
left_join(flights2, weather)
# by = NULL이면 두 table에서 공통적으로 나타나는 모든 변수를 합침.
```

```{r}
flights2 %>%
  left_join(planes, by = "tailnum")
```

by = c("a" = "b"): match variable a in table x to the variable b in table y.

즉, flights2의 "dest" 변수와 airports의 "faa" 변수를 동일시하여 합침.
```{r}
flights2 %>%
  left_join(airports, c("dest" = "faa"))
```

```{r}
flights %>%
  left_join(airports, c("origin" = "faa"))
```

# Filtering joins  

```{r}
top_dest <- flights %>%
  count(dest, sort = TRUE) %>%
  head(10)
top_dest
```

# Semi_join (filtering의 일종종)
semi_join(x, y) only keeps the rows in x that have a match in y.  
즉, x에서 y에 있는 행만 남김.  


```{r}
semi_join(flights, top_dest)
# by = NULL이므로, top_dest에 있는 모든 열로 filtering 했을 것임.
```
# Anti_join  
anti_join(x, y) keeps the rows that don’t have a match. 
semi_join의 반대. y에 없는 행만 남김.  
```{r}
flights %>% 
  anti_join(planes, by = "tailnum") %>%
  count(tailnum, sort = TRUE)
# planes에 없는 tailnum을 갖는 행만 남기고 정렬함.  
```

# Set operation  

```{r}
    df1 <- tribble(
      ~x, ~y,
       1,  1,
       2,  1
    )
    df2 <- tribble(
      ~x, ~y,
       1,  1,
       1,  2
    )
```

```{r}
intersect(df1, df2)
```
```{r}
union(df1, df2)
```

```{r}
setdiff(df1, df2)
```
```{r}
setdiff(df2, df1)
```

```{r}
library("stringr")
```

```{r}
string1 <- "This is a string"
string2 <- 'If I want to include a "quote" inside a string, I use single quotes'
```

```{r}
#string3 <- "double "quote""
double_quote<-"\""
double_quote
double_quote<-'"'
double_quote
```
```{r}
single_quote<-"\'"
single_quote
single_quote<-"'"
single_quote
```
```{r}
x <- "\uc804\uc0b0\ud1b5\uacc4"
x
```
```{r}
y <- "\u96fb\u7b97\u7d71\u8a08"
y
```
```{r}
c("one", "two", "three")
```
# String length  

```{r}
str_length("R for data science")
```
```{r}
str_length(c("a", "R for data science", NA))
```
# Combining strings  

```{r}
str_c("x", "y")
```
```{r}
str_c("x", "y", "z")
```
```{r}
str_c("x", "y", sep = ",")
```
```{r}
str_c("prefix-", c("a", "b", "c"), "-suffix")
```
```{r}
str_c(c("a", "b", "c"), c("a", "b", "c"), "hello")
```

```{r}
name <- "Hadley"
time_of_day <- "morning"
birthday <- TRUE

str_c(
  "Good ", time_of_day, " ", name,
  if (birthday) " and HAPPY BIRTHDAY",
  "."
)
```
```{r}
str_c(c("x", "y", "z"))
```
combine a vector of strings
```{r}
str_c(c("x", "y", "z"), collapse = ". ")
```

# Subsetting strings  

```{r}
str_sub("Apple", 1, 3)
```
```{r}
str_sub("가나다라마바사", 1, 3)
```
```{r}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)
```
```{r}
str_sub(x, -3, -1)
# 마지막에서 세 번째 ~ 마지막에서 첫 번째째
```
```{r}
str_sub("a", 1, 5)
```
```{r}
str_sub("a", 2, 5)
```
```{r}
str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))
# x의 첫 번째 자리에 x의 첫 번째 자리를 소문자로 바꾼 문자열을 대입하겠다.
x
```
# Matching patterns with regular expressions

str_view_all: 모든 문자열을 보여줌.
```{r}
x <- c("apple", "banana", "pear", "anti")
str_view_all(x, "an")
```
str_view: 매칭되는 애들만 보여줌.
```{r}
x <- c("apple", "banana", "pear", "anti")
str_view(x, "an")
```
.: 임의의 문자를 나타냄.
즉, 아래 코드는 '(임의의 문자)a(임의의 문자)'가 들어간 애들을 출력해달라는 뜻.

```{r}
str_view_all(x, ".a.")
```
리터럴리 마침표를 의미하고 싶다면 \\.을 입력하면 됨.
```{r}
str_view_all(c("abc", "a.c", "bef"), "a\\.c")
```
리터럴리 \를 의미하고 싶은 것이면 \\를 사용하면 됨.
```{r}
str_view_all("a\\b", "\\\\")
```
# Anchors  

^: 문자열의 시작을 의미미

```{r}
x <- c("apple", "banana", "pear")
str_view_all(x, "^a")
```
$: 문자열의 끝을 의미  

```{r}
x <- c("apple", "banana", "pear")
str_view_all(x, "a$")
```
```{r}
x <- c("apple pie", "apple", "apple_cake", "pine apple")
str_view_all(x, "^apple$")
```
```{r}
str_view_all(x, "apple$")
```

\d: 숫자만을 의미
\s: 공백만을 의미 (space, tab, newline)
[abc]: a or b or c
[^abc]: a, b, c 빼고 전부  

```{r}
str_view_all(c("grey", "gray"), "gr(e|a)y")
```
```{r}
str_view_all(c("grey", "gray"), "gr[ea]y")
```
# Repetition  

?: 0번 또는 1번
+: 1번 이상
*: 0번 이상

```{r}
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view_all(x, "CC?")
# C가 0번 또는 1번.
# 즉, 위 정규표현식은 C 또는 CC를 의미.
```
```{r}
str_view_all(x, "CC+")
# C가 1번 이상.
# 즉, 위 정규표현식은 CC, CCC, CCCC, ...를 의미
```
```{r}
str_view_all(x, "C[LX]+")
# L 또는 X가 1번 이상.
```
{n}: 정확히 n번
{n, }: n번 이상
{,m}: m번 이하
{n, m}: n번 이상, m번 이하하

```{r}
str_view_all(x, "C{2}")
```
```{r}
str_view_all(x, "C{2,}")
```
```{r}
str_view_all(x, "C{2,3}")
```
뒤에 ?를 넣는 것을 lazy match라 한다.


```{r}
str_view_all(x, 'C{2,3}?')
```
```{r}
str_view_all(x, 'C[LX]+?')
```

Parentheses define groups, which can be back-referenced as \1, \2, …

"(..)\\1": 이 정규 표현식은 두 글자가 반복되는 부분을 나타냅니다. 여기서 (..)는 두 글자를 그룹화하고, \\1은 첫 번째 그룹과 동일한 내용을 나타냅니다.

```{r}
fruit <- c("apple", "banana", "coconut", "cucumber", "jujube", "papaya", "salal berry")
str_view_all(fruit, "(..)\\1", match = TRUE)
```
```{r}
str_view_all(fruit, "(..)(..)\\2", match = TRUE)
```

\\2를 사용하면 정규 표현식에서 두 번째 그룹과 동일한 부분을 나타냅니다. 따라서 두 글자가 두 번 반복되는 부분을 찾는 것이 됩니다.  

```{r}
str_view_all("lapmpmhello", "(..)(..)\\2", match = TRUE)
```
# Detect matches  

str_detect: 해당 표현식이 있는지 없는지 확인 (logical 반환)

```{r}
x <- c("apple", "banana", "pear")
str_detect(x, "e")
```
```{r}
length(words)
```
```{r}
head(words)
```
```{r}
sum(str_detect(words, "^t"))
# t로 시작하는 단어들의 개수수
```
```{r}
mean(str_detect(words, "[aeiou]$"))
# 모음으로 끝나는 단어의 비율율
```
```{r}
words[str_detect(words, "x$")]
```
str_subset: 해당 표현식이 있는 문자열만을 반환

```{r}
str_subset(words, "x$")
```
str_count: 각 문자열에서 표현식이 나타나는 횟수를 반환

```{r}
x <- c("apple", "banana", "pear")
str_count(x, "a")
```
```{r}
str_count("abababa", "aba")
# matches never overlap  
```
```{r}
str_view_all("abababa", "aba")
```

# Extract matches  

```{r}
length(sentences)
```
```{r}
head(sentences)
```
```{r}
colours <- c("red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match
```
위 정규표현식은 red or orange or yellow or green or blue or purple을 의미한다.  

str_extract: 각 문자열에서, 해당 표현식이 나오는 첫 번째 부분만을 출력.  
str_extract_all: 각 문자열에서, 해당 표현식이 나오는 모든 부분을 출력.  

```{r}
has_colour <- str_subset(sentences, colour_match)
matches <- str_extract(has_colour, colour_match)
head(matches)
```
```{r}
matches <- str_extract_all(has_colour, colour_match)
matches[20]
```
```{r}
more <- sentences[str_count(sentences, colour_match) > 1]
str_view_all(more, colour_match)
```


```{r}
str_extract_all(more, colour_match, simplify = TRUE)
```
```{r}
str_extract_all(more, colour_match)
```
```{r}
x <- c("a", "a b", "a b c")
str_extract_all(x, "[a-z]", simplify = TRUE)
```
# Grouped matches  

```{r}
noun <- "(a|the) ([^ ]+)"   
# a 또는 the 뒤에 공백 후 공백이 아닌 문자열 1개 이상.

has_noun <- sentences %>%
  str_subset(noun) %>%
  head(10)
has_noun %>%
  str_extract(noun)
```
str_match: 패턴을 소괄호로 묶어주면 각각에 대한 성분을 따로 출력해줌.  

```{r}
has_noun %>%
  str_match(noun)
```
```{r}
tibble(sentence = sentences) %>%
  tidyr::extract(
    sentence, c("article", "noun"), "(a|the) ([^ ]+)",
    remove = FALSE
  )
```

# Replacing matches  

```{r}
x <- c("apple", "pear", "banana")
str_replace(x, "[aeiou]", "-")
# 첫 번째로 나오는 모음을 -로 변환. 
```
```{r}
str_replace_all(x, "[aeiou]", "-")
```
```{r}
x <- c("1 house", "2 cars", "3 people")
str_replace_all(x, c("1" = "one", "2" = "two", "3" = "three"))
```
```{r}
sentences %>%
  head(5)
```


```{r}
sentences %>% 
  str_replace("([^ ]+) ([^ ]+) ([^ ]+)", "\\1 \\3 \\2") %>% 
  head(5)
```
# Splitting  

str_split: 문자열에서 해당 패턴을 구분자로 인식하여 이들을 분해 후 리스트로 변환.  

```{r}
sentences %>%
  head(5) %>%
  str_split(" ")
```

```{r}
sentences %>%
  head(5) %>% 
  str_split(" ", simplify = TRUE)
```
```{r}
fields <- c("Name: Hadley", "Country: NZ", "Age: 35")
fields %>% str_split(": ", n = 1)
```
```{r}
fields %>% str_split(": ", n = 4, simplify = TRUE)
```
```{r}
x <- "This is a sentence.  This is another sentence."
str_view_all(x, boundary("word"))
```
```{r}
str_view_all(x, boundary("character"))
```
```{r}
str_view_all(x, boundary("sentence"))
```
```{r}
str_split(x, " ")[[1]]
```
```{r}
str_split(x, boundary("word"))[[1]]
```


