---
title: "hw4"
author: "HyeongHwan Kim"
date: "2023-11-21"
output: html_document
---

```{r}
library(ggplot2)
```


```{r}
library(readr)
```

```{r}
library(tibble)
```

```{r}
library(nycflights13)
```
```{r}
library(purrr)
```

```{r}
library(dplyr)
```
```{r}
library(modelr)
```
```{r}
library(lubridate)
```
```{r}
library(MASS)
```
```{r}
library(forcats)
```


# Textbook 20.3.5  
## Problem 5  
What functions from the readr package allow you to turn a string into logical, integer, and double vector?  

```{r}
parse_logical(c("true", "false"))
```
```{r}
parse_integer(c("1", "5", "4"))
```
```{r}
parse_double(c("1.2", "12.16", "3.14"))
```

# Textbook 20.4.6  
## Problem 1  
What does mean(is.na(x)) tell you about a vector x? What about sum(!is.finite(x))?  

```{r}
x <- c(1, NA, 3, NA, 8)
mean(is.na(x))
```
'mean(is.na(x))' means the proportion of NA data in vector x.  

```{r}
x <- c(1, Inf, 3, Inf, 8, NA)
sum(!is.finite(x))
```
'sum(!is.finite(x))' means the number of Inf or NA data in vector x.  

## Problem 4  
Create functions that take a vector as input and returns:
1. The last value. Should you use [ or [[?  
2. The elements at even numbered positions.  
3. Every element except the last value.  
4. Only even numbers (and no missing values).  

```{r}
return_last_value <- function(X){
  return(x[length(x)])
}
x <- c(1, 2, 3, 4, 5)
return_last_value(x)
```
```{r}
return_even_position <- function(X){
  return(x[seq(from = 2, to = length(x), by = 2)])
}
x <- c(1, 2, 3, 4, 5)
return_even_position(x)
```
```{r}
return_except_last_value <- function(x){
  return(x[-length(x)])
}
x <- c(1, 2, 3, 4, 5)
return_except_last_value(x)
```
```{r}
return_even_noNA <- function(x) {
  vec <- x[seq(from = 2, to = length(x), by = 2)]
  return(vec[!is.na(vec)])
}
x <- c(1, 2, NA, 4, 5, NA, 7, 8, 9, NA)
return_even_noNA(x)
```
# Textbook 20.5.4  
## Problem 2  
What happens if you subset a tibble as if you’re subsetting a list? What are the key differences between a list and a tibble?  

```{r}
my_tibble <- tibble(
  x = tibble(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)),
  y = c("A", "B", "C"),
  z = c(-2.8, 4.1, 9.7)
)
```

```{r}
my_list <- list(list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)), c("A", "B", "C"), c(-2.8, 4.1, 9.7))
```

```{r}
my_tibble[[1]][[1]]
```
```{r}
my_list[[1]][[1]]
```
It works same as the list. However, when using tibble, we should set the length of each column to be same. 

```{r, error = T}
my_tibble <- tibble(
  x = tibble(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)),
  y = c("A", "B"),
  z = c(-2.8, 4.1, 9.7)
)
```


# Textbook 21.2.1  
## Problem 1  
Write for loops to:
1. Compute the mean of every column in mtcars.  
2. Determine the type of each column in nycflights13::flights.  
3. Compute the number of unique values in each column of iris.  
4. Generate 10 random normals from distributions with means of -10, 0, 10, and 100.  
Think about the output, sequence, and body before you start writing the loop.


```{r}
output <- vector("double", ncol(mtcars))
for(i in seq_along(mtcars)){
  output[[i]] <- mean(mtcars[[i]])
}
output
```
```{r}
output <- vector("character", ncol(flights))
for(i in seq_along(flights)){
  output[[i]] <- typeof(flights[[i]])
}
output
```
```{r}
output <- vector("integer", ncol(iris))
for(i in seq_along(iris)){
  output[[i]] <- length(unique(iris[[i]]))
}
output
```

```{r}
mean_vec <- c(-10, 0, 10, 100)
output <- vector("list", length(mean_vec))
for(i in seq_along(mean_vec)){
  output[[i]] <- rnorm(mean = mean_vec[i], n = 10)
}
output
```
# Textbook 21.3.5  
## Problem 3  
Write a function that prints the mean of each numeric column in a data frame, along with its name. For example, show_mean(iris) would print:  
(Extra challenge: what function did I use to make sure that the numbers lined up nicely, even though the variable names had different lengths?)

```{r}
show_mean <- function(df){
  df <- df[, sapply(df, is.numeric)]
  mean_output <- list()
  col_names <- paste0(colnames(df), ":")
  col_names <- format(col_names, width = max(nchar(col_names)), justify = "left")
  for(i in seq_along(df)){
    output[[i]]<-paste(col_names[[i]], output[[i]] <- format(round(mean(df[[i]]), digits = 2)), sep = " ")
    print(output[[i]])
  }
  
}
show_mean(iris)
```
# Textbook 21.4.1  
## Problem 1  
Read the documentation for apply(). In the 2d case, what two for loops does it generalize?  

```{r}
mat <- matrix(1:12, nrow = 3)
```


```{r}
apply(mat, MARGIN = 1, FUN = sum)
output_1 <- vector("integer", nrow(mat))
for(i in 1:nrow(mat)){
  output_1[i] <- sum(mat[i, ])
}
print(output_1)
```
```{r}
apply(mat, MARGIN = 2, FUN = sum)
output_2 <- vector("integer", ncol(mat))
for(j in 1:ncol(mat)){
  output_2[j] <- sum(mat[,j ])
}
print(output_2)
```
# Textbook 21.5.3  
## Problem 1  
Write code that uses one of the map functions to:
1. Compute the mean of every column in mtcars.  
2. Determine the type of each column in nycflights13::flights.  
3. Compute the number of unique values in each column of iris.  
4. Generate 10 random normals from distributions with means of -10, 0, 10, and 100.  
Think about the output, sequence, and body before you start writing the loop.

```{r}
map_dbl(mtcars, mean)
```

```{r}
map_chr(flights, typeof)
```
```{r}
map_int(iris, n_distinct)
```
```{r}
map(c(-10, 0, 10, 100), ~rnorm(10, mean = .))
```
# Textbook 21.9.3  
## Problem 2  
Create an enhanced col_summary() that applies a summary function to every numeric column in a data frame.  

```{r}
col_summary <- function(df, fun) {
  out <- vector("character", length(df))
  for (i in seq_along(df)) {
    if(is.numeric(df[,i]))
      out[i] <- paste(colnames(df)[i], fun(df[[i]]), sep = ": ")
  }
  out[out != ""]
}

col_summary(iris, mean)
```

# Textbook 23.2.1  
## Problem 1  

One downside of the linear model is that it is sensitive to unusual values because the distance incorporates a squared term. Fit a linear model to the simulated data below, and visualise the results. Rerun a few times to generate different simulated datasets. What do you notice about the model?  

```{r}
set.seed(1589)
for(i in 1:10) {
  sim1a <- tibble(
    x = rep(1:10, each = 3),
    y = x * 1.5 + 6 + rt(length(x), df = 2)
  )
  
  lm_model <- lm(y ~ x, data = sim1a)
  print(summary(lm_model))
  
  print(ggplot(data = sim1a) +
  geom_point(mapping = aes(x = x, y = y)) +
  geom_abline(intercept = lm_model$coefficients[1], slope = lm_model$coefficients[2], col = "red")) +
  ggtitle(paste(lm_model$coefficients[1], lm_model$coefficients[2], sep = " "))
}
```
As seeing plot 2, there is an extreme outlier on the left side of the plot. Because of that, the intercept decreases to 3.64. In plot 3, not only the intercept changes significantly but also the x-coefficient. Therefore, it can be said that linear regression model is vulnerable to the outlier.  

## Problem 2  
One way to make linear models more robust is to use a different distance measure. For example, instead of root-mean-squared distance, you could use mean-absolute distance:  

```{r}
model1 <- function(a, data) {
  a[1] + data$x * a[2]
}
```


```{r}
measure_distance <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  mean(abs(diff))
}
```

Use optim() to fit this model to the simulated data above and compare it to the linear model.  

```{r}
best <- optim(par = c(0, 0), fn = measure_distance, data = sim1a)
```

```{r}
lm_model <- lm(y ~ x, data = sim1a)
lm_model$coefficients
```

```{r}
ggplot(data = sim1a) +
  geom_point(mapping = aes(x = x, y = y)) +
  geom_abline(intercept = best$par[1], slope = best$par[2], col = "red") +
  geom_abline(intercept = lm_model$coefficients[1], slope = lm_model$coefficients[2], col = "blue")
```
The lines obtained from two methods are quite similar. Since we use L1-loss to optimize linear model, two lines are not same.  

# Textbook 23.3.3  
## Problem 1  
Instead of using lm() to fit a straight line, you can use loess() to fit a smooth curve. Repeat the process of model fitting, grid generation, predictions, and visualisation on sim1 using loess() instead of lm(). How does the result compare to geom_smooth()?  

```{r}
loess_model <- loess(y ~ x, data = sim1a)

grid <- sim1a %>%
  data_grid(x)

grid <- grid %>%
  add_predictions(loess_model)

ggplot(data = sim1a) +
  geom_point(mapping = aes(x = x, y = y)) +
  geom_line(mapping = aes(x = x, y = pred), data = grid, color = "red") +
  geom_smooth(mapping = aes(x = x, y = y), linewidth = 0.01)
```
Two lines are exactly same.  

# Textbook 23.4.5  
## Problem 3  
Using the basic principles, convert the formulas in the following two models into functions. (Hint: start by converting the categorical variable into 0-1 variables.)  

```{r}
head(sim3, 3)
```


```{r}
mod1 <- function(df) {
  variable_names <- c("x1")

  for(lv in levels(df$x2)[2:length(levels(df$x2))]){
    variable_name <- paste0("x2", lv)
    variable_names <- append(variable_names, variable_name)
    df[variable_name] <- ifelse(df$x2 == lv, 1, 0)
  }
  mod_y <- df$y
  df <- df[variable_names]
  mod <- lm(mod_y ~ as.matrix(df))
  return(mod)
}

my_lm_model <- mod1(sim3)
lm_model <- lm(y ~ x1 + x2, data = sim3)
my_lm_model
lm_model
# Two results are same.
```

```{r}
mod2 <- function(df) {
  variable_names <- c("x1")

  for(lv in levels(df$x2)[2:length(levels(df$x2))]){
    variable_name <- paste0("x2", lv)
    variable_names <- append(variable_names, variable_name)
    df[variable_name] <- ifelse(df$x2 == lv, 1, 0)
  }
  for(var in variable_names[2:length(variable_names)]){
    variable_name <- paste0("x1:", var)
    variable_names <- append(variable_names, variable_name)
    df[variable_name] <- df$x1 * df[var]
  }
  mod_y <- df$y
  df <- df[variable_names]
  mod <- lm(mod_y ~ as.matrix(df))
  return(mod)
}
my_lm_model <- mod2(sim3)
lm_model <- lm(y ~ x1 * x2, data = sim3)
my_lm_model
lm_model
# Two results are same.
```
# Textbook 24.2.3  
## Problem 2  
If log(price) = a_0 + a_1 * log(carat), what does that say about the relationship between price and carat?  

It is equivalent as price = exp(a_0) * carat^a_1
That is to say price is proportional to carat^r.

# Textbook 24.3.5  
## Problem 2  
What do the three days with high positive residuals represent? How would these days generalise to another year? 

```{r}
daily <- flights %>% 
  mutate(date = make_date(year, month, day)) %>% 
  group_by(date) %>% 
  summarise(n = n())
daily <- daily %>% 
  mutate(wday = wday(date, label = TRUE))
mod <- lm(n ~ wday, data = daily)
daily <- daily %>% 
  add_residuals(mod)
```
```{r}
daily %>% 
  slice_max(n = 3, resid)
```

They are all next weekend of the holiday. For example, 11/30 and 12/1 is next Saturday and Sunday of Thanksgiving day, and 12/28 is next Saturday of Christmas. So it can be generalized in terms of the holidays.  

## Problem 4  
Create a new wday variable that combines the day of week, term (for Saturdays), and public holidays. What do the residuals of that model look like?  

```{r}
term <- function(date) {
  cut(date, 
    breaks = ymd(20130101, 20130605, 20130825, 20140101),
    labels = c("spring", "summer", "fall") 
  )
}

daily <- daily %>% 
  mutate(term = term(date)) 
```

```{r}
public_holidays <- ymd(c("20130101", "20130121", "20130218", "20130527", "20130704", "20130902", "20131014", "20131111", "20131128", "20131225"))
```

```{r}
public_holidays
```
To strengthen the effect of the holiday, I added two more levels, "holiday_before" and "holiday_after".

```{r}
daily <- daily %>%
  mutate(wday_new =
           case_when(date %in% public_holidays ~ "holiday",
                     date %in% (public_holidays - 1L) ~ "holiday_before",
                     date %in% (public_holidays + 1L) ~ "holiday_after",
                     wday == "토" ~ term,
                     TRUE ~ wday)) 
```

```{r}
new_model <- rlm(n ~ wday_new, data = daily)
```

```{r}
daily <- daily %>% 
  add_residuals(new_model, "resid_new")

daily %>% ggplot(aes(date, resid_new)) + 
  geom_hline(yintercept = 0, size = 2, colour = "white") + 
  geom_line()
```
It fits well generally after February except for some outliers. The model underestimates n in winter, and there are a bit of overestimations in summer.  

## Problem 8  
It’s a little frustrating that Sunday and Saturday are on separate ends of the plot. Write a small function to set the levels of the factor so that the week starts on Monday.  

```{r}
change_level <- function(vec) {
  vec <- fct_relevel(vec, levels(vec)[-1])
  return(vec)
}

mod <- lm(n ~ wday, data = daily)

grid <- daily %>% 
  data_grid(wday) %>% 
  add_predictions(mod, "n")

daily %>%
  mutate(wday = change_level(wday)) %>%
  ggplot(daily, mapping = aes(x = wday, y = n)) + 
  geom_boxplot() +
  geom_point(data = grid, colour = "red", size = 4)
```

