---
title: "hw2"
author: "HyeongHwan Kim"
date: "2023-10-07"
output: html_document
---

```{r, eval = FALSE}
install.packages("ggplot2")
```

```{r, eval = FALSE}
install.packages("dplyr")
```

```{r, eval = FALSE}
install.packages("tidyverse")
```
```{r, eval = FALSE}
install.packages("Lahman")
```
```{r, eval = FALSE}
install.packages("igraph")
```
```{r, eval = FALSE}
install.packages("dm")
```



```{r}
library(ggplot2)
```

```{r}
library(dplyr)
```

```{r}
library(tidyverse)
```


```{r}
library(Lahman)
```

# 11.3.3  
## Problem 1  

 Explore the distribution of each of the x, y, and z variables in diamonds. What do you learn? Think about a diamond and how you might decide which dimension is the length, width, and depth.  
 
```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = x), binwidth = 0.5)
```



```{r}
ggplot(data = diamonds) +
  geom_boxplot(mapping = aes(y = x)) +
  coord_cartesian(ylim = c(3, 10))
```


```{r}

ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) + 
  scale_x_continuous(limits = c(0, 11))

```


```{r}

ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) + 
  coord_cartesian(ylim = c(0, 50))
  #scale_x_continuous(limits = c(0, 11))

```

```{r}
ggplot(data = diamonds) +
  geom_boxplot(mapping = aes(y = y)) +
  coord_cartesian(ylim = c(3, 10))
```

```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = z), binwidth = 0.5)  +
  scale_x_continuous(limits = c(-1, 8))
```

```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = z), binwidth = 0.5)  +
  coord_cartesian(ylim = c(0, 50))
```


In general, the depth of diamonds is shorter than their length and width. And z-value is located on the left side in the histogram, comparing with x and y-value. Therefore, it seems that the z variable represents depth.  


```{r}
ggplot(data = diamonds) +
  geom_boxplot(mapping = aes(y = x/y)) +
  coord_cartesian(ylim = c(0.99, 1.02))
```

```{r}
ggplot(data = diamonds) +
  geom_boxplot(mapping = aes(y = x/y)) 
```

```{r}
diamonds %>%
  filter(x/y > 1.02 | x/y < 0.98) %>%
  select(x, y) %>%
  mutate(ratio = x/y)
```

```{r}
diamonds %>%
  filter(x/y > 1.02) %>%
  nrow()
```

```{r}
diamonds %>%
  filter(x/y < 0.98) %>%
  nrow()
```
 When examining the data on the L/W (length-to-width) ratio, I discovered that the length values should generally exceed the width values. Consequently, when plotting the boxplot for x/y, I found that, on average, the x/y values were below 1. This observation might suggest that considering x as width and y as length is reasonable. However, after filtering outliers, it became evident that there were more cases where the x/y value exceeded 1.02 compared to those below 0.98. Additionally, cases where the x value is less than 0.98 include instances where x is missing.  
 I think analyzing outlier is more reasonable to interpret x as length and y as width. The rationale behind this choice is that when x/y values are close to 1, diamonds are likely to be mostly circular, increasing the probability of measurement errors. Conversely, when x/y values are far from 1, it indicates that diamonds are not perfectly circular, making the distinction between length and width more apparent. Hence, I believe interpreting x as length and y as width is a more rational approach.


## Problem 2

 Explore the distribution of price. Do you discover anything unusual or surprising? (Hint: Carefully think about the binwidth and make sure you try a wide range of values.)  


```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price), binwidth = 10)
```

```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price), binwidth = 10) +
  coord_cartesian(xlim = c(0, 1000))
```

The histogram increases until the price reaches around 700, and after that, it decreases exponentially.

```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price), binwidth = 10) +
  coord_cartesian(xlim = c(1400, 1600))
```

 There are no data with values roughly between 1450 and 1550!  
 
 
## Problem 3

 How many diamonds are 0.99 carat? How many are 1 carat? What do you think is the cause of the difference?


```{r}
diamonds %>%
  filter(carat == 0.99) %>%
  nrow()
```

```{r}
diamonds %>%
  filter(carat == 1) %>%
  nrow()
```

```{r}
diamonds %>%
  group_by(carat) %>%
  summarise(mean_price = mean(price)) %>%
  filter(carat >= 0.97 & carat <= 1.03) %>%
  select(mean_price, carat)
```

```{r}
filtered_diamonds <- diamonds %>%
  filter(carat >= 0.97 & carat <= 1.03)

filtered_diamonds$carat <- as.factor(filtered_diamonds$carat)

ggplot(data = filtered_diamonds) +
  geom_boxplot(mapping = aes(x = carat, y = price))
```

 Even though there is only a 0.01 carat difference between 0.99 carats and 1 carat, the difference in the leading digit can result in a significant price gap. Upon calculating the average price and plotting a boxplot, it becomes evident that the prices are significantly higher for diamonds weighing 1 carat or more.
 

## Problem 4  
 Compare and contrast coord_cartesian() vs. xlim() or ylim() when zooming in on a histogram. What happens if you leave binwidth unset? What happens if you try and zoom so only half a bar shows?  
 
 
```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price), binwidth = 100) +
  coord_cartesian(xlim = c(1000, 5000))
```

 
```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price), binwidth = 100) +
  xlim(c(1000, 5000))
```

 About limiting x-coord, coord_cartesian displays data 'roughly' within that range but xlim displays data 'exactly' within that range. Seeing above plots, the x-range of first one is approximately 900 to 5100. However second one is 1000 to 5000. Also second one shows warning message indicating that the data has been removed.
 What these mean, if coord_cartesian draws the histogram for the entire dataset and then displays only the portion corresponding to the specified range, and xlim retains only the data within the specified range and draws the histogram based on that subset of data.


```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price), binwidth = 100) +
  coord_cartesian(ylim = c(0, 1000))
```


```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price), binwidth = 100) +
  ylim(c(0, 1000))
```

 This difference is more apparent in the y-range. When using the ylim function, if the data does not fall within that range, it is removed and not plotted.


```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price)) +
  coord_cartesian(xlim = c(1000, 5000))
```


```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price)) +
  xlim(c(1000, 5000))
```

 If the binwidth parameter is unset, ggplot automatically fills in the bin value as 30 and draws the histogram. When using the xlim function, the data itself is deleted, and the histogram is drawn for the remaining data, applying bin = 30 within that range. On the other hand, when using the coord_cartesian function, it draws the graph for the entire dataset and then cuts it to show, resulting in a relatively wider binwidth compared to using xlim function.

 So, it is only possible to display half a bar when using the coord_cartesian function.

```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price), binwidth = 500) +
  coord_cartesian(xlim = c(750, 1000))
```


```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price), binwidth = 500) +
  coord_cartesian(xlim = c(1000, 1250))
```

```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = price), binwidth = 500) +
  xlim(c(1000, 1250))

# Impossible!
```


# 11.4.1
## Problem 1  

 What happens to missing values in a histogram? What happens to missing values in a bar chart? Why is there a difference in how missing values are handled in histograms and bar charts?
 
```{r}
diamonds2 <- diamonds %>% 
  mutate(y = ifelse(y < 3 | y > 20, NA, y))
```

```{r}
ggplot(diamonds2) + 
  geom_histogram(mapping = aes(x = y))
```



```{r}
diamonds2 <- diamonds %>%
  mutate(clarity = ifelse(clarity == 'I1', NA, clarity))
```

```{r}
ggplot(diamonds2) +
  geom_bar(mapping = aes(x = clarity))
```

```{r}
diamonds2 <- diamonds
diamonds2$clarity[1:30000] <- NA
```

```{r}
head(diamonds2, 30)
```


```{r}
ggplot(diamonds2) +
  geom_bar(mapping = aes(x = clarity))
```

```{r}
ggplot(diamonds) +
  geom_bar(mapping = aes(x = clarity))
```

 In the case of a histogram, it counts the values excluding the missing ones. For a bar plot, a new category named "NA" is created, and the graph is drawn with this additional category.
 
## Problem 2  

 What does na.rm = TRUE do in mean() and sum()?  
 
```{r}
diamonds2 <- diamonds %>% 
  mutate(y = ifelse(y < 3 | y > 20, NA, y))

diamonds2 %>%
  select(y) %>%
  summarise(y_mean = mean(y))
```
```{r}
diamonds2 %>%
  select(y) %>%
  summarise(y_mean = mean(y, na.rm = TRUE))
```

```{r}
diamonds2 %>%
  select(y) %>%
  summarise(y_sum = sum(y))
```

```{r}
diamonds2 %>%
  select(y) %>%
  summarise(y_sum = sum(y, na.rm = TRUE))
```

 If na.rm = FALSE, if returns NA when NA values are included in the data. However, if na.rm = TRUE, sum() and mean() functions return the value excluding NA values.  

# 6.2.1  
## Problem 2 (table 2)  

  Sketch out the process you’d use to calculate the rate for table2 and table3. You will need to perform four operations:

a. Extract the number of TB cases per country per year.
b. Extract the matching population per country per year.
c. Divide cases by population, and multiply by 10000.
d. Store back in the appropriate place.

 You haven’t yet learned all the functions you’d need to actually perform these operations, but you should still be able to think through the transformations you’d need.  

a.  

```{r}
table_case <- table2 %>%
  filter(type == "cases") %>%
  group_by(country, year) %>%
  select(country, year, count)

table_case
```

b.  

```{r}
table_pop <- table2 %>%
  filter(type == "population") %>%
  group_by(country, year) %>%
  select(country, year, count)

table_pop
```

c, d.  

```{r}
table_prop <- table_pop 
table_prop$prop <- table_case$count / table_pop$count * 10000

table_prop %>%
  select(country, year, prop)
```

# 8.2.4  
## Problem 5  

 Identify what is wrong with each of the following inline CSV files. What happens when you run the code?  


```{r}
read_csv("a,b\n1,2,3\n4,5,6")
```

 The number of columns is 2, but there is an issue with parsing as each row contains 3 pieces of data. The last two pieces of data are combined and displayed as "23, 56".  

```{r}
read_csv("a,b,c\n1,2\n1,2,3,4")
```

 This data also exhibits a mismatch between the number of columns and the number of data entries in each row, leading to issues such as missing values or data being combined.

```{r}
read_csv("a,b\n\"1")
```


 Mismatched quotation marks caused issues when loading the file.  

```{r}
df <- read_csv("a,b\n1,2\na,b", show_col_types = FALSE)
df
```

 Rows with different data types between them caused numeric variables to be converted into character variables.


```{r}
read_csv("a;b\n1;3")
```
 The data is not properly parsed because the delimiter used in the code is a semicolon instead of comma.  


# 20.2.4  
## Problem 5  

 Draw a diagram illustrating the connections between the Batting, People, and Salaries data frames in the Lahman package. Draw another diagram that shows the relationship between People, Managers, AwardsManagers. How would you characterize the relationship between the Batting, Pitching, and Fielding data frames?  
 
```{r}
head(Batting, 3)
```
```{r}
Batting %>%
  nrow()
```

```{r}
Batting %>%
  select(playerID, yearID, stint) %>%
  unique() %>%
  nrow()
```
 The primary keys of Batting are (playerID, yearID, stint).

```{r}
head(People, 3)
```

```{r}
People %>%
  nrow()
```

```{r}
People %>%
  select(playerID) %>%
  unique() %>%
  nrow()
```

 The primary key of People is playerID

```{r}
head(Salaries, 3)
```

```{r}
Salaries %>%
  nrow()
```
```{r}
Salaries %>%
  select(yearID, teamID,playerID) %>%
  unique() %>%
  nrow()
```
 The primary key of People is yearID, teamID and playerID.
 
 
```{r}
library(dm)
```

 
```{r}

dm1 <- dm(
  Batting = Batting, People = People, Salaries = Salaries
) %>%
  dm_add_pk(table = Batting, columns = c(playerID, yearID, stint)) %>%
  dm_add_pk(table = People, columns = c(playerID)) %>%
  dm_add_pk(table = Salaries, columns = c(playerID, yearID, teamID)) %>%
  dm_add_fk(People, playerID, Batting, playerID) %>%
  dm_add_fk(People, playerID, Salaries, playerID)

dm1 %>%
  dm_draw()

```

I don't know how to display playerID connected to the arrow primary key...  So please ignore the duplicate columns :(  

```{r}
Managers %>%
  select(yearID, teamID, inseason) %>%
  unique() %>%
  nrow()
```
```{r}
Managers %>%
  nrow()
```
```{r}
AwardsManagers %>%
  select(playerID, awardID, yearID) %>%
  unique() %>%
  nrow()
```
```{r}
AwardsManagers %>%
  nrow()
```

```{r}
dm2 <- dm(
  People = People,  Managers = Managers, AwardsManagers = AwardsManagers
) %>%
  dm_add_pk(table = People, columns = c(playerID)) %>%
  dm_add_pk(table = Managers, columns = c(yearID, teamID, inseason)) %>%
  dm_add_pk(table = AwardsManagers, columns = c(playerID, awardID, yearID)) %>%
  dm_add_fk(People, playerID, Managers, playerID) %>%
  dm_add_fk(People, playerID, AwardsManagers, playerID)

dm2 %>%
  dm_draw()
```


playerID of AwardsManager is primary key...  

```{r}
Pitching %>%
  select(playerID, yearID, stint) %>%
  unique() %>%
  nrow()
```
```{r}
Pitching %>%
  nrow()
```
```{r}
Fielding %>%
  select(playerID, yearID, stint, POS) %>%
  unique() %>%
  nrow()
```
```{r}
Fielding %>%
  nrow()
```

```{r}
dm3 <- dm(
  Batting = Batting, Pitching = Pitching, Fielding = Fielding
) %>%
  dm_add_pk(table = Batting, columns = c(playerID, yearID, stint)) %>%
  dm_add_pk(table = Pitching, columns = c(playerID, yearID, stint)) %>%
  dm_add_pk(table = Fielding, columns = c(playerID, yearID, stint, POS)) %>%
  dm_add_fk(Pitching, c(playerID, yearID, stint), Batting) %>%
  dm_add_fk(Fielding, c(playerID, yearID, stint), Batting)

dm3 %>%
  dm_draw()
```

Also playerID, yearID, and stint is primary key.

The Batting, Pitching, and Fielding datasets all share the variables playerID, yearID, and stint.

# 15.2.4  
## Problem 1  

Create strings that contain the following values:

```{r}
# He said "That's amazing!"

str1 <- 'He said "That\'s amazing!"'
str_view(str1)
```


```{r}
# \a\b\c\d

str2 <- '\\a\\b\\c\\d'
str_view(str2)
```

```{r}
# \\\\\\

str3 <- '\\\\\\\\\\\\'
str_view(str3)
```

# 15.3.4  
## Problem 1  

 Compare and contrast the results of paste0() with str_c() for the following inputs:
 
```{r}
str_c("hi ", NA)
```
```{r}
paste0("hi ", NA)
```
 str_c function recognizes NA as "not a number" and returns it as the result. On the other hand, paste0 converts NA to a string and concatenates it with the preceding string, resulting in "hi NA."

```{r, eval = FALSE}
letters<-c('a', 'b', 'c')
str_c(letters[1:2], letters[1:3])
```


```{r}
letters<-c('a', 'b', 'c')
paste0(letters[1:2], letters[1:3])
```
```{r}
str_c(c('a', 'b', 'c'), c('a', 'b', 'c'))
```
 When putting vectors of different lengths into the str_c function, an error occurs, indicating that the lengths are not the same. This error arises because str_c cannot handle inputs with mismatched lengths.

 On the other hand, the paste0 function automatically adjusts the lengths of vectors by cycling them when they are of different lengths. This allows the function to execute smoothly even when dealing with vectors of varying lengths.

## Problem 3  

Convert the following expressions from str_c() to str_glue() or vice versa:  

```{r}
# str_c("The price of ", food, " is ", price)

food <- "chicken"
price <- 20000

str1 <- str_glue("The price of {food} is {price}")
str_view(str1)
```

```{r}
# str_glue("I'm {age} years old and live in {country}")

age <- 21
country <- "South Korea"

str2 <- str_c("I\'m ", age, " years old and live in ", country)
str_view(str2)
```
```{r}
# str_c("\\section{", title, "}")

title <- "Strings"

str3 <- str_glue("\\\\section{{{title}}")
str_view(str3)
```