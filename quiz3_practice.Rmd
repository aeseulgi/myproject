---
title: "quiz3_practice"
author: "HyeongHwan Kim"
date: "2023-12-11"
output: html_document
---

# Factors  

```{r}
library(forcats)
library(dplyr)
library(ggplot2)
```

```{r}
x1 <- c("Dec", "Apr", "Jan", "Mar")
```

```{r}
sort(x1)
```
```{r}
month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun",
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
y1 <- factor(x1, levels = month_levels)
y1
```
```{r}
sort(y1)
```
```{r}
x2 <- c("Dec", "Apr", "Jam", "Mar")
```

```{r}
y2 <- factor(x2, levels = month_levels)
y2
```
```{r}
factor(x1) # omitting levels
```
```{r}
levels(y1)
```

# General Social Survey  

```{r}
forcats::gss_cat
```

```{r}
gss_cat %>%
  count(race)
```

```{r}
ggplot(gss_cat, aes(race)) +
  geom_bar() +
  scale_x_discrete(drop = FALSE)
```

# Modifying factor order  

```{r}
relig_summary <- gss_cat %>%
  group_by(relig) %>%
  summarise(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(relig_summary, aes(tvhours, relig)) + geom_point()
```
```{r}
relig_summary
ggplot(relig_summary, aes(tvhours, fct_reorder(relig, tvhours))) +
  geom_point()
```
fct_reorder(f, x, fun):  
  f: 레벨을 변경하고 싶은 factor
  x: numerical vector, 이 자식의 level별 median을 기준으로 오름차순  

```{r}
relig_summary %>%
  mutate(relig = fct_reorder(relig, tvhours)) %>%
  ggplot(aes(tvhours, relig)) +
    geom_point()
```

```{r}
rincome_summary <- gss_cat %>%
  group_by(rincome) %>%
  summarise(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(rincome_summary, aes(age, fct_reorder(rincome, age))) + geom_point()
```
```{r}
ggplot(rincome_summary, aes(age, fct_relevel(rincome, "Not applicable"))) +
  geom_point()
```

fct_relevel:  
  얘는 원하는 순서로 정렬. 
  지정하지 않은 애들은 맨 뒤로 감감
  
# Modifying factor levels  

```{r}
gss_cat %>% count(partyid)
```
```{r}
gss_cat %>%
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat"
  )) %>%
  count(partyid)
```
fct_recode:
  factor 이름 다시 설정  
  new = old
  
  하나의 new에 여러 개의 old를 넣어도 된다.  

```{r}
gss_cat %>%
  mutate(partyid = fct_recode(partyid,
                              "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat",
    "Other"                 = "No answer",
    "Other"                 = "Don't know",
    "Other"                 = "Other party")) %>%
  count(partyid)
``` 

```{r}
gss_cat %>%
  mutate(partyid = fct_collapse(partyid,
    other = c("No answer", "Don't know", "Other party"),
    rep = c("Strong republican", "Not str republican"),
    ind = c("Ind,near rep", "Independent", "Ind,near dem"),
    dem = c("Not str democrat", "Strong democrat")
  )) %>%
  count(partyid)
```

fct_lump:  
  fct_lump(factor, n, other_level = 이름)
  n = 10: level을 10개로 구성한다는 뜻. count가 적은 애들은 하나로 묶는다.  

```{r}
gss_cat %>%
  mutate(relig = fct_lump(relig, n = 10)) %>%
  count(relig, sort = TRUE) %>%
  print(n = Inf)
```

# Dates and times

```{r}
library(lubridate)
library(hms)
library(readr)
```
# Creating date/times  
## readr  

```{r}
parse_date("2020-01-01")
```
```{r}
parse_date(c("2018-03-24", "1234-10-23"))
```
## lubridate  

```{r}
ymd("2017-01-31")
```
```{r}
# 이상함  
mdy("January 31st, 2017")
```
```{r}
ymd_hms("2017-01-31 20:11:59")
```
```{r}
mdy_hm("01/31/2017 08:01")
```

# From individual components  

```{r}
library(nycflights13)
```
make_date(year, month, day) 하면 날짜 형식 데이터가 나옴.  
make_datetime(year, month, day, hour, minute, second)  


```{r}
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

ends_with(문자열): 문자열로 끝나는 애들 선택

```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights %>% 
  filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) %>% 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

geom_freqpoly: geom_histogram이랑 유사한 앤데 꺾은선으로 표시.  

```{r}
flights_dt %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day
```

```{r}
flights_dt %>% 
  filter(dep_time < ymd(20130102)) %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes
```

# From other types  


```{r}
as_datetime(today(tzone = "UTC"))
```
```{r}
as_date(now())
```
```{r}
as_datetime(now())
```
# Date-time components  

## Getting components  

```{r}
year("2022-12-31")
```
```{r}
year(as_datetime("2022-12-31"))
```
```{r}
wday("2023-12-10")
```
wday에서 1: 일요일 ~ 7: 토요일  

```{r}
yday("2023-12-11")
```
```{r}
mday("2023-12-11")
```

```{r}
flights_dt %>% 
  mutate(wday = wday(dep_time, label = TRUE)) %>% 
  ggplot(aes(x = wday)) +
    geom_bar()
```

```{r}
flights_dt %>% 
  mutate(wday = wday(dep_time, label = TRUE)) %>% 
  mutate(wday = fct_recode(wday, "Sun" = "일", "Mon" = "월", "Tue" = "화", "Wed" = "수", "Thu" = "목", "Fri"= "금", "Sat" = "토")) %>%
  ggplot(aes(x = wday)) +
    geom_bar()
```

```{r}
flights_dt %>% 
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()) %>% 
  ggplot(aes(minute, avg_delay)) +
    geom_line()
```

```{r}
sched_dep <- flights_dt %>% 
  mutate(minute = minute(sched_dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n())

ggplot(sched_dep, aes(minute, avg_delay)) +
  geom_line()
```

```{r}
ggplot(sched_dep, aes(minute, n)) +
  geom_line()
```

# Rounding  

```{r}
floor_date(ymd(20231213), "week")
```
```{r}
floor_date(ymd(20231211), "month")
```

```{r}
flights_dt %>% 
  count(week = floor_date(dep_time, "week")) %>% 
  ggplot(aes(week, n)) +
    geom_line()
```

# Setting components  

```{r}
datetime <- ymd_hms("2016-07-08 12:34:56")
```

```{r}
year(datetime) <- 2020
datetime
```
```{r}
update(datetime, year = 2020, month = 2, mday = 2, hour = 2)
```
Distribution of flights across the course of the day for every day of the year: (모든 월을 1월로 통일했으므로)

```{r}
flights_dt %>% 
  mutate(dep_hour = update(dep_time, yday = 1)) %>% 
  ggplot(aes(dep_hour)) +
    geom_freqpoly(binwidth = 300)
```

# Time arithmetic  
## Duration

```{r}
h_age <- today() - ymd(19791014)
as.duration(h_age)
```
```{r}
2 * dyears(1)
```
```{r}
dyears(1) + dweeks(12) + dhours(15)
```
```{r}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

```{r}
tomorrow
```
```{r}
last_year
```
```{r}
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")

one_pm

```
```{r}
one_pm + ddays(1)
```

상식: EST... 가을/겨울, EDT... 봄/여름, 두 시간대는 1시간 차이 난다고 한다.  

## Periods  

```{r}
one_pm
```
```{r}
one_pm + days(1)
```
왜 이런 차이?  
Duration은 time-based values (seconds 기준)  
Period는 date-based values (year, month, day 기준)  

```{r}
flights_dt %>% 
  filter(arr_time < dep_time) %>%
    select(origin, dest, dep_time, arr_time)
```


```{r}
flights_dt %>% 
  filter(arr_time < dep_time) %>%
    select(origin, dest, dep_time, arr_time)
```

하루 넘어간 경우 처리하기  

```{r}
flights_dt <- flights_dt %>% 
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight * 1),  # why * 1? (integer로 만들려고...)
    sched_arr_time = sched_arr_time + days(overnight * 1)
  )
```

```{r}
flights_dt %>% 
  filter(overnight, arr_time < dep_time) 
```

## Intervals  

```{r}
dyears(1) / ddays(365)
```
```{r}
years(1) / days(1)
```

%--%: interval 관련 함수.  

```{r}
next_year <- today() +years(1)
(today() %--% next_year) / ddays(1)
```

```{r}
next_year - today()
```
```{r}
today() %--% next_year
```
# Time zones  

```{r}
Sys.timezone()
```
```{r}
x1 <- ymd_hms("2015-06-01 12:00:00", tz = "America/New_York")
```

```{r}
(x2 <- ymd_hms("2015-06-01 18:00:00", tz = "Europe/Copenhagen"))
```
```{r}
x1 - x2
```
## UTC  
```{r}
x3 <- ymd_hms(now())
x3
```
```{r}
x3a <- with_tz(x3, tzone = "Asia/Shanghai") # 같은 시각이 되도록 시각과 시간대 모두 변경
x3a
```
```{r}
x3b <- force_tz(x3, tzone = "Asia/Shanghai") # 시간은 유지하고 시간대만 옮김
x3b
```

# Functions  

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

Name, Arguments, Body

# Conditional execution  

NEVER use | or & in an if statement.  
You shoule use || or &&

```{r}
has_name <- function(x) {
  nms <- names(x)
  if (is.null(nms)) {
    rep(FALSE, length(x))
  } else {
    !is.na(nms) & nms != ""
  }
}
```

```{r}
function(x, y, op) {
  switch(op,
    plus = x + y,
    minus = x - y,
    times = x * y,
    divide = x / y,
    stop("Unknown op!")
  )
}
```

## Default values

```{r}
mean_ci <- function(x, conf = 0.95) {
  se <- sd(x) / sqrt(length(x))
  alpha <- 1 - conf
  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))
}

x <- runif(100)
mean_ci(x)
```

## Checking values  
stop function  
stop(문자열): 해당 문자열을 출력하고 실행 종료.   

```{r, error = TRUE}
wt_mean <- function(x, w) {
  if (length(x) != length(w)) {
    stop("`x` and `w` must be the same length", call. = FALSE)
  }
  sum(w * x) / sum(w)
}

wt_mean(1:6, 1:3)
```

stopifnot(조건): 조건을 만족하지 않으면 멈춤.  

```{r, error = TRUE}
wt_mean <- function(x, w, na.rm = FALSE) {
  stopifnot(is.logical(na.rm), length(na.rm) == 1)
  stopifnot(length(x) == length(w))
  
  if (na.rm) {
    miss <- is.na(x) | is.na(w)
    x <- x[!miss]
    w <- w[!miss]
  }
  sum(w * x) / sum(w)
}
wt_mean(1:6, 6:1, na.rm = "foo")
```

## Dot-dot-dot (...)  
arbitrary number of inputs.  

```{r}
letters <- c("a", "b", "c", "d", "e", "f", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "w", "x", "y", "z")
commas <- function(...) stringr::str_c(..., collapse = ", ")
commas(letters[1:10])
```
```{r}
complicated_function <- function(x, y, z) {
  if (length(x) == 0 || length(y) == 0) {
    return(0)  # return early
  }
    
  # Complicated code here
}
```

## Pipeable functions  

A pipeable function should return a data frame.

transformations: an object is passed to the function’s first argument and a modified object is returned.

Functions with side-effects: the passed object is not transformed. Instead, the function performs an action on the object, like drawing a plot or saving a file.

Side-effects functions should “invisibly” return the first argument, so that while they’re not printed they can still be used in a pipeline:

```{r}
show_missings <- function(df) {
  n <- sum(is.na(df))
  cat("Missing values: ", n, "\n", sep = "")
  
  invisible(df) # return(df)인데 결과 출력이 안 됨
}
```


```{r}
show_missings(mtcars)
```
```{r}
mtcars %>% 
  show_missings() %>% 
  mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>% 
  show_missings() 
```

# Vectors  

```{r}
typeof(letters)
```
```{r}
typeof(1:10)
```
```{r}
x <- list("a", "b", 1:10)
length(x)
```
```{r}
1:10 %% 3 == 0
```
```{r}
c(TRUE, TRUE, FALSE, NA)
```
```{r}
typeof(1)
```
```{r}
typeof(1L) # 정수형으로 변환하기 위해 뒤에 L을 붙이면 됨.  
```
```{r}
xx <- c(-1, 0, 1) / 0
```

```{r}
is.finite(xx)
```
```{r}
is.infinite(xx)
```
```{r}
is.na(xx)
```
```{r}
is.nan(xx)
```

```{r}
x <- sample(20, 100, replace = TRUE)
y <- x > 10
sum(y)
```
```{r}
mean(y)
```
```{r}
typeof(c(TRUE, 1L))
```
```{r}
typeof(c(1L, 1.5))
```
```{r}
typeof(c(1.5, "a"))
```
```{r}
sample(10) + 100
```
```{r}
runif(10) > 0.5
```

```{r}
1:10 + 1:2 # recycling
```
```{r, error = TRUE}
1:10 + 1:3
```
```{r, error = TRUE}
tibble(x = 1:4, y = 1:2)
```

```{r}
tibble(x = 1:4, y = rep(1:2, 2))
```

```{r}
tibble(x = 1:4, y = rep(1:2, each = 2))
```

```{r}
tibble(x=1:4, y=1)  # this is allowed
```

```{r}
c(x = 1, y = 2, z = 4)
```
```{r}
purrr::set_names(1:3, c("a", "b", "c"))
```
## Subsetting  

```{r}
x <- c("one", "two", "three", "four", "five")
x[c(3, 2, 5)]
```
```{r}
x[c(1, 1, 5, 5, 5, 2)]
```
```{r, error = TRUE}
x[1, 2]
```
```{r}
x[c(-1, -3, -5)]
# Negative values drop the elements at the specified positions:
```
```{r}
x[0]
```
```{r, error = TRUE}
x[c(1, -1)]
```
```{r}
x <- c(10, 3, NA, 5, 8, 1, NA)

# All non-missing values of x
x[!is.na(x)]
```

```{r}
x[x %% 2 == 0]
```

```{r}
x <- c(abc = 1, def = 2, xyz = 5)
x[c("xyz", "def")]
```
```{r}
x[c("xyz", "def", "xyz")]
```
```{r}
x <- c(1, 2, 3)
x[]
```
```{r}
y <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2)
y
```
```{r}
y[1,]
```

```{r}
y[,-1]
```

# Lists  

```{r}
x <- list(1, 2, 3)
x
```
```{r}
str(x)
```
```{r}
x_named <- list(a = 1, b = 2, c = 3)
str(x_named)
```
```{r}
y <- list("a", 1L, 1.5, TRUE)
```

```{r}
x1 <- list(c(1, 2), c(3, 4))
x2 <- list(list(1, 2), list(3, 4))
x3 <- list(1, list(2, list(3)))
```

```{r}
a <- list(a = 1:3, b = "a string", c = pi, d = list(-1, -5))
```

[ extracts a sub-list. The result will always be a list.

```{r}
a[1]
```
[[ extracts a single component from a list. It removes a level of hierarchy from the list.  

```{r}
a[[1]]
```
```{r}
a[[1]][2]
```
$ is a shorthand for extracting named elements of a list. It works similarly to [[ except that you don’t need to use quotes.  

```{r}
a$d[[1]]
```
```{r}
a["a"]
```
```{r}
a[["a"]]
```
# Attributes  

```{r}
x <- 1:10
attr(x, "greeting")
```
```{r}
attr(x, "greeting") <- "Hi!"  # set an individual attribute
attr(x, "farewell") <- "Bye!" # set an individual attribute
attributes(x)  # get all at once
```
변수 x에 greeting이라는 속성에 Hi!라는 값을 대입하겠다.  
```{r}
x
```
# Generic functions  

```{r}
as.Date
```

```{r}
getS3method("as.Date", "default")
```

```{r}
print
```
```{r}
methods("print") %>%head(5)
```
# Augmented vectors  

Factors are built on top of integers, and have a levels attribute:

```{r}
x <- factor(c("ab", "cd", "ab"), levels = c("ab", "cd", "ef"))
typeof(x)
```

```{r}
unclass(x)
attributes(x)
```
Dates in R are numeric vectors that represent the number of days since 1 January 1970:  

```{r}
x <- as.Date("1971-01-01")
unclass(x) # factor를 integer로 만듦.
```
```{r}
unclass(as.Date("1972-01-01"))
```
```{r}
typeof(x)
```
```{r}
attributes(x)
```
```{r}
x <- lubridate::ymd_hm("1970-01-01 01:00")
unclass(x)
```
```{r}
typeof(x)
```
```{r}
attributes(x)
```
```{r}
attr(x, "tzone") <- "Asia/Seoul"
```

```{r}
attr(x, "tzone") <- "Asia/Shanghai"
x
```

```{r}
tb <- tibble::tibble(x = 1:5, y = 5:1)
typeof(tb)
```
```{r}
unclass(tb)
```
```{r}
attributes(tb)
```
The difference between a tibble and a list is that all the elements of a data frame must be vectors with the same length. All functions that work with tibbles enforce this constraint.  

```{r}
df <- data.frame(x = 1:5, y = 5:1)
typeof(df)
```

```{r}
attributes(df)
```
The main difference is the class. The class of tibble includes “data.frame” which means tibbles inherit the regular data frame behaviour by default.  

```{r}
is.data.frame(df)
is.data.frame(tb)
tibble::is_tibble(df)
tibble::is_tibble(tb)
```

# Iterations  

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

```{r}
df[1]
```
```{r}
df[[1]]
```

seq_along(data_frame): data_frame의 길이만큼 1부터 시작하는 벡터 반환 1:n

```{r}
output <- vector("double", ncol(df))
for(i in seq_along(df)) {
  output[[i]] <- median(df[[i]])
}
output
```
Always try to use [[, not [ all for loops: it makes it clear that I want to work with a single element.  

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

```{r}
for(i in seq_along(df)){
  df[[i]] <- rescale01(df[[i]])
}
```
```{r}
for(i in seq_along(x)) {
  name <- names(x)[[i]]
  value <- x[[i]]
}
```
## Unknown output length  

오 벡터 append를 이렇게 하는군  
x <- c(x, 다른 원소)

```{r}
means <- c(0, 1, 2)

output <- double()
for (i in seq_along(means)) {
  n <- sample(100, 1)
  # progressively growing the vector `output`
  output <- c(output, rnorm(n, means[[i]]))
}
str(output)
```
```{r}
x <- c(1, 2, 3)
x <- c(x, 4)
x
```
```{r}
# more efficient

out <- vector("list", length(means))
for (i in seq_along(means)) {
  n <- sample(100, 1)
  out[[i]] <- rnorm(n, means[[i]])
}
str(out)
```
```{r}
str(unlist(out))
```
unlist: flattens a list of vectors into a single vector.  

When generating a long string. Instead of paste()ing together each iteration with the previous, save the output in a character vector and then combine that vector into a single string with paste(output, collapse = "").  

When generating a big data frame. Instead of sequentially rbind()ing in each iteration, save the output in a list, then use dplyr::bind_rows(output) to combine the output into a single data frame.  

결론은 반복 때마다 추가하지 말고 한 번에 합치라는 뜻  

```{r}
i <- 1
while (i <= length(x)) {
  # body
  i <- i + 1 
}
```

```{r}
flip <- function() sample(c("T", "H"), 1)

flips <- 0
nheads <- 0

while (nheads < 3) {
  if (flip() == "H") {
    nheads <- nheads + 1
  } else {
    nheads <- 0
  }
  flips <- flips + 1
}
flips
```

# Map functions  

```{r}
library(purrr)
```

data frame이 input으로 주어지면 각 column별로 특정 함수를 수행함.  

purrr::map() makes a list.
purrr::map_lgl() makes a logical vector.
purrr::map_int() makes an integer vector.
purrr::map_dbl() makes a double vector.
purrr::map_chr() makes a character vector.

```{r}
map_dbl(df, mean)
```
```{r}
map_dbl(df, median)
```
```{r}
df %>% map_dbl(mean)
```
```{r}
models <- mtcars %>% 
  split(.$cyl) %>% 
  map(function(df) lm(mpg ~ wt, data = df))
```

The . refers to the current list element.  

split(column): column의 unique한 값들로 데이터프레임을 분할한다. 

```{r}
models <- mtcars %>% 
  split(.$cyl) %>% 
  map(~lm(mpg ~ wt, data = .))
```

~는 function(df)로 치환된다.  

```{r}
mtcars %>%
  split(.$cyl)
```

```{r}
models %>% 
  map(summary) %>% 
  map_dbl(~.$r.squared)
```
Select elements by position:  

```{r}
x <- list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9))
x %>% map_dbl(2)
```
```{r}
map_dbl(x, 1)
```

lapply: list (dataframe, matrix 포함)를 입력값으로 받아 각각의 변수에 특정 함수를 동시 적용하여 list를 출력.  
sapply: vector 혹은 matrix를 출력. (교재 설명 보니 출력 형태를 예측하기 어렵다고 한다.)

```{r}
x1 <- list(
  c(0.27, 0.37, 0.57, 0.91, 0.20),
  c(0.90, 0.94, 0.66, 0.63, 0.06), 
  c(0.21, 0.18, 0.69, 0.38, 0.77)
)
x2 <- list(
  c(0.50, 0.72, 0.99, 0.38, 0.78), 
  c(0.93, 0.21, 0.65, 0.13, 0.27), 
  c(0.39, 0.01, 0.38, 0.87, 0.34)
)

threshold <- function(x, cutoff = 0.8) x[x > cutoff]
x1 %>% sapply(threshold)
```
```{r}
x2 %>% sapply(threshold)
```


# Dealing with failure  

맵 함수를 사용해 많은 연산을 반복할 때, 연산 중 하나가 실패할 확률이 매우 높다. 이 경우 오류 메시지가 표시되고 출력은 표시되지 않는다. safely()를 사용하여 이러한 상황을 다루는 법을 배울 것 이다. safely()는 부사이다. 함수(동사) 를 사용하고 수정된 버전을 반환 한다. 이 경우 수정된 버전은 오류를 발생시키지 않는다. 대신 항상 다음의 두 요소로 이루어진 리스트를 반환한다.  

```{r}
safe_log <- safely(log) # 그 로그 함수 그거거
str(safe_log(10))
```
```{r}
str(safe_log("a"))
```
```{r}
x <- list(1, 10 ,"a")
y <- x %>% map(safely(log))
```

```{r}
y <- y %>% purrr::transpose()
str(y)
```
```{r}
is_ok <- y$error %>% map_lgl(is_null)
x[!is_ok]
```
```{r}
y$result[is_ok] %>% flatten_dbl()
```
possibly(): you give it a default value to return when there is an error.

```{r}
x <- list(1, 10, "a")
x %>% map_dbl(possibly(log, NA_real_))
```
quietly() performs a similar role to safely(), but instead of capturing errors, it captures printed output, messages, and warnings:  

```{r}
x <- list(1, -1)
x %>% map(quietly(log)) %>% str()
```
# Mapping over multiple arguments  

```{r}
mu <- list(5, 10, -3)
mu %>%
  map(rnorm, n = 5) %>%
  str()
```

Use map2() which iterates over two vectors in parallel:  

```{r}
sigma <- list(1, 5, 10)
map2(mu, sigma, rnorm, n = 5) %>% str()
```
pmpp: function을 적용할 대상이 중첩 리스트로 이루어져 있을 때 각각에 대해서 파라미터를 뽑아 함수 적용. 

```{r}
n <- list(1, 3, 5)
args1 <- list(n, mu, sigma)
args1 %>%
  pmap(rnorm) %>% 
  str()
# rnorm(n[[i]], mu[[i]], sigma[[i]])가 3번 반복됨.  
```
```{r}
params <- tribble(
  ~mean, ~sd, ~n,
    5,     1,  1,
   10,     5,  3,
   -3,    10,  5
)
params %>% 
  pmap(rnorm)
```
# Invoking different functions  

```{r}
f <- c("runif", "rnorm", "rpois")
param <- list(
  list(min = -1, max = 1), 
  list(sd = 5), 
  list(lambda = 10)
)
```

```{r}
invoke_map(f, param, n = 5) %>% str()
# 각 f에 같은 index의 param이 대응됨.
```
```{r}
sim <- tribble(
  ~f,      ~params,
  "runif", list(min = -1, max = 1),
  "rnorm", list(sd = 5),
  "rpois", list(lambda = 10)
)
sim %>% 
  mutate(sim = invoke_map(f, params, n = 10))
```

```{r}
x <- list(1, "a", 3)
x %>%
  walk(print)
```
walk(), walk2(), pwalk()는 모두 첫 번째 인수 .x를 보이지 않게 반환한다. 따라서 이 함수들을 파이프라인 중간에서 사용하기 적절하다.  

```{r}
x %>%
  map(print)
```
# Reduce and accumulate  



```{r}
dfs <- list(
  age = tibble(name = "John", age = 30),
  sex = tibble(name = c("John", "Mary"), sex = c("M", "F")),
  trt = tibble(name = "Mary", treatment = "A")
)

dfs %>% reduce(full_join)
```

```{r}
vs <- list(
  c(1, 3, 5, 6, 10),
  c(1, 2, 3, 7, 8, 10),
  c(1, 2, 3, 4, 8, 9, 10)
)

vs %>% reduce(intersect)
```
```{r}
x <- sample(10)
x %>% accumulate(`+`)
```
